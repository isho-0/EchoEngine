<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>STT/TTS Full Test (Web Speech API)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 20px; }
    textarea { width: 100%; height: 160px; padding: 10px; box-sizing: border-box; }
    button { padding: 10px 12px; margin: 6px 6px 6px 0; }
    .row { margin: 12px 0; }
    .status { padding: 8px 10px; background: #f3f4f6; border-radius: 8px; }
    .hint { color: #555; font-size: 13px; }
    .grid { display: grid; grid-template-columns: 140px 1fr; gap: 10px; align-items: center; }
    select, input[type="range"], input[type="number"] { width: 100%; }
    code { background: #f3f4f6; padding: 2px 6px; border-radius: 6px; }
    .hl {
      border-left: 4px solid #e5e7eb;
      padding: 8px 10px;
      background: #fafafa;
      border-radius: 8px;
      white-space: pre-wrap;
      word-break: break-word;
    }
  </style>
</head>
<body>
  <h2>Web Speech API STT / TTS í…ŒìŠ¤íŠ¸ (ê³ ê¸‰ ì„¤ì • í¬í•¨)</h2>

  <div class="row status" id="status">ìƒíƒœ: ì´ˆê¸°í™” ì¤‘...</div>
  <div class="row hint" id="support"></div>

  <h3>1) STT (SpeechRecognition)</h3>
  <div class="row">
    <button id="btnStart">ğŸ¤ STT ì‹œì‘</button>
    <button id="btnStop" disabled>ğŸ›‘ STT ì¤‘ì§€</button>

    <label class="hint">
      <input type="checkbox" id="chkInterim" checked />
      ì¤‘ê°„ê²°ê³¼(interim) í‘œì‹œ
    </label>

    <label class="hint" style="margin-left:10px;">
      <input type="checkbox" id="chkContinuous" checked />
      ì—°ì† ì¸ì‹(continuous)
    </label>

    <!-- âœ… ì¶”ê°€: STT ì–¸ì–´ ì„ íƒ (TTS ì–¸ì–´ì™€ ë¶„ë¦¬) -->
    <label class="hint" style="margin-left:10px;">
      STT ì–¸ì–´:
      <select id="sttLang" style="width:auto;">
        <option value="ko-KR" selected>í•œêµ­ì–´ (ko-KR)</option>
        <option value="en-US">ì˜ì–´ (en-US)</option>
      </select>
    </label>
  </div>

  <h3>2) í…ìŠ¤íŠ¸</h3>
  <div class="row">
    <textarea id="text" placeholder="ì—¬ê¸°ì— STT ê²°ê³¼ê°€ ìŒ“ì´ê³ , TTSë¡œ ì½ì„ í…ìŠ¤íŠ¸ë„ ì…ë ¥í•  ìˆ˜ ìˆì–´ìš”."></textarea>
  </div>

  <h3>3) TTS (speechSynthesis) - ìŒì„±/ê¸°íƒ€ ì„¤ì •</h3>
  <div class="row grid">
    <div><label for="lang">ì–¸ì–´(lang)</label></div>
    <div>
      <select id="lang">
        <option value="ko-KR" selected>ko-KR</option>
        <option value="en-US">en-US</option>
        <option value="ja-JP">ja-JP</option>
        <option value="zh-CN">zh-CN</option>
      </select>
      <div class="hint">â€» ì‹¤ì œ ì‚¬ìš© ê°€ëŠ¥í•œ voiceëŠ” OS/ë¸Œë¼ìš°ì €ì— ë”°ë¼ ë‹¬ë¼ìš”.</div>
    </div>

    <div><label for="voice">ìŒì„±(voice)</label></div>
    <div>
      <select id="voice"></select>
      <div class="hint">ëª©ë¡ì´ ë¹„ì–´ìˆìœ¼ë©´ 1~2ì´ˆ í›„ ë‹¤ì‹œ ëœ° ìˆ˜ ìˆì–´ìš”(voiceschanged).</div>
    </div>

    <div><label for="rate">ì†ë„(rate)</label></div>
    <div>
      <input id="rate" type="range" min="0.5" max="2" step="0.1" value="1" />
      <div class="hint">í˜„ì¬: <span id="rateVal">1.0</span></div>
    </div>

    <div><label for="pitch">í”¼ì¹˜(pitch)</label></div>
    <div>
      <input id="pitch" type="range" min="0" max="2" step="0.1" value="1" />
      <div class="hint">í˜„ì¬: <span id="pitchVal">1.0</span></div>
    </div>

    <div><label for="volume">ë³¼ë¥¨(volume)</label></div>
    <div>
      <input id="volume" type="range" min="0" max="1" step="0.05" value="1" />
      <div class="hint">í˜„ì¬: <span id="volumeVal">1.00</span></div>
    </div>

    <div><label for="chunkLen">ë¶„í•  ê¸¸ì´</label></div>
    <div>
      <input id="chunkLen" type="number" min="80" max="500" step="10" value="180" />
      <div class="hint">ê¸´ í…ìŠ¤íŠ¸ë¥¼ ìë™ ë¶„í• (ëŒ€ëµ Nì ë‹¨ìœ„). ëŠê¹€/ì˜¤ë¥˜ ë°©ì§€ìš©.</div>
    </div>

    <div><label for="autoPick">ìë™ voice ì„ íƒ</label></div>
    <div>
      <label class="hint">
        <input type="checkbox" id="autoPick" checked />
        ì–¸ì–´ì— ë§ëŠ” voice ìë™ ì„ íƒ
      </label>
      <div class="hint">ì–¸ì–´ ë³€ê²½ ì‹œ í•´ë‹¹ ì–¸ì–´ voiceë¥¼ ìš°ì„ ìœ¼ë¡œ ê³ ë¦…ë‹ˆë‹¤.</div>
    </div>

    <div><label for="queueMode">ëŒ€ê¸°ì—´ ëª¨ë“œ</label></div>
    <div>
      <label class="hint">
        <input type="checkbox" id="queueMode" />
        ê¸°ì¡´ ë°œí™” ì·¨ì†Œí•˜ì§€ ì•Šê³  ì´ì–´ ì½ê¸°(Queue)
      </label>
      <div class="hint">ë„ë©´ <code>cancel()</code> í›„ ìƒˆë¡œ ì½ìŠµë‹ˆë‹¤.</div>
    </div>

    <div><label>ì»¨íŠ¸ë¡¤</label></div>
    <div>
      <button id="btnSpeak">ğŸ”Š ì½ê¸°</button>
      <button id="btnPause">â¸ï¸ ì¼ì‹œì •ì§€</button>
      <button id="btnResume">â–¶ï¸ ì¬ê°œ</button>
      <button id="btnCancel">âœ‹ ì·¨ì†Œ</button>
      <label class="hint" style="margin-left:10px;">
        <input type="checkbox" id="chkBoundary" checked />
        boundary(ì½ëŠ” ìœ„ì¹˜) ì¶”ì 
      </label>
    </div>
  </div>

  <h3>4) ì½ëŠ” ìœ„ì¹˜(í•˜ì´ë¼ì´íŠ¸)</h3>
  <div class="row hl" id="highlight">(TTS ì‹œì‘í•˜ë©´ í˜„ì¬ ì½ëŠ” ìœ„ì¹˜ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤)</div>

<script>
(() => {
  const statusEl = document.getElementById('status');
  const supportEl = document.getElementById('support');
  const textEl = document.getElementById('text');

  // STT
  const btnStart = document.getElementById('btnStart');
  const btnStop  = document.getElementById('btnStop');
  const chkInterim = document.getElementById('chkInterim');
  const chkContinuous = document.getElementById('chkContinuous');
  const sttLangEl = document.getElementById('sttLang'); // âœ… ì¶”ê°€

  // TTS UI
  const langEl = document.getElementById('lang');
  const voiceEl = document.getElementById('voice');
  const rateEl = document.getElementById('rate');
  const pitchEl = document.getElementById('pitch');
  const volumeEl = document.getElementById('volume');
  const chunkLenEl = document.getElementById('chunkLen');
  const autoPickEl = document.getElementById('autoPick');
  const queueModeEl = document.getElementById('queueMode');

  const rateVal = document.getElementById('rateVal');
  const pitchVal = document.getElementById('pitchVal');
  const volumeVal = document.getElementById('volumeVal');

  const btnSpeak = document.getElementById('btnSpeak');
  const btnPause = document.getElementById('btnPause');
  const btnResume = document.getElementById('btnResume');
  const btnCancel = document.getElementById('btnCancel');
  const chkBoundary = document.getElementById('chkBoundary');

  const hlEl = document.getElementById('highlight');

  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  const hasSTT = !!SpeechRecognition;
  const hasTTS = !!window.speechSynthesis;

  supportEl.textContent =
    `ì§€ì› ì—¬ë¶€ â†’ STT(SpeechRecognition): ${hasSTT ? 'OK' : 'NO'} / TTS(speechSynthesis): ${hasTTS ? 'OK' : 'NO'}`;

  function setStatus(msg) { statusEl.textContent = 'ìƒíƒœ: ' + msg; }

  function updateRanges() {
    rateVal.textContent = Number(rateEl.value).toFixed(1);
    pitchVal.textContent = Number(pitchEl.value).toFixed(1);
    volumeVal.textContent = Number(volumeEl.value).toFixed(2);
  }
  rateEl.addEventListener('input', updateRanges);
  pitchEl.addEventListener('input', updateRanges);
  volumeEl.addEventListener('input', updateRanges);
  updateRanges();

  // -------------------- STT --------------------
  let rec = null;
  let isRecognizing = false;

  function startSTT() {
    if (!hasSTT) { alert('STT ë¯¸ì§€ì› ë¸Œë¼ìš°ì €ì…ë‹ˆë‹¤(Chrome ê¶Œì¥).'); return; }
    if (isRecognizing) return;

    rec = new SpeechRecognition();

    // âœ… í•µì‹¬: STT ì–¸ì–´ëŠ” TTS(langEl)ì™€ ë¶„ë¦¬í•´ì„œ ì„ íƒ
    rec.lang = sttLangEl.value;

    rec.continuous = chkContinuous.checked;

    // âœ… ì˜ì–´(en-US)ì—ì„œ interimì´ í”ë“¤ë¦¬ëŠ” ê²½ìš°ê°€ ë§ì•„ ìë™ìœ¼ë¡œ ë”(ì›í•˜ë©´ ì•„ë˜ í•œ ì¤„ ìˆ˜ì • ê°€ëŠ¥)
    rec.interimResults = (rec.lang === 'ko-KR') ? chkInterim.checked : false;

    // âœ… í›„ë³´ ë” ë°›ê¸°(ì˜ì–´ ì¸ì‹ ê°œì„ ì— ë„ì›€ë  ìˆ˜ ìˆìŒ)
    rec.maxAlternatives = 5;

    rec.onstart = () => {
      isRecognizing = true;
      btnStart.disabled = true;
      btnStop.disabled = false;
      setStatus(`STT ì¸ì‹ ì¤‘... (lang=${rec.lang}) ë§ˆì´í¬ë¡œ ë§í•´ë³´ì„¸ìš”.`);
    };

    rec.onresult = (event) => {
      let finalText = '';
      let interimText = '';

      for (let i = event.resultIndex; i < event.results.length; i++) {
        const r = event.results[i];
        const t = r[0].transcript;
        if (r.isFinal) finalText += t;
        else interimText += t;
      }

      if (finalText.trim()) {
        const sep = textEl.value && !textEl.value.endsWith('\n') ? '\n' : '';
        textEl.value += sep + finalText.trim();
      }
      if (chkInterim.checked && interimText.trim()) {
        setStatus(`STT ì¸ì‹ ì¤‘... (ì¤‘ê°„ê²°ê³¼) ${interimText.trim()}`);
      }
    };

    rec.onerror = (e) => {
      console.error('STT ì—ëŸ¬:', e.error);
      setStatus(`STT ì—ëŸ¬: ${e.error}`);
      // íŠ¹ì • ì˜¤ë¥˜ëŠ” ìë™ ì¬ì‹œì‘í•˜ì§€ ì•ŠìŒ
      if (e.error === 'not-allowed' || e.error === 'no-speech' || e.error === 'aborted') {
        isRecognizing = false;
        btnStart.disabled = false;
        btnStop.disabled = true;
        setStatus('STT ì¢…ë£Œë¨ (ë§ˆì´í¬ ê¶Œí•œì„ í™•ì¸í•˜ì„¸ìš”)');
      }
    };
    
    rec.onend = () => {
      // continuous ëª¨ë“œì´ê³  ì‚¬ìš©ìê°€ ì¤‘ì§€í•˜ì§€ ì•Šì•˜ìœ¼ë©´ ìë™ ì¬ì‹œì‘
      if (rec.continuous && isRecognizing) {
        try {
          rec.start();
          setStatus('STT ì¬ì‹œì‘ ì¤‘...');
        } catch (err) {
          console.error('STT ì¬ì‹œì‘ ì‹¤íŒ¨:', err);
          isRecognizing = false;
          btnStart.disabled = false;
          btnStop.disabled = true;
          setStatus('STT ì¢…ë£Œë¨');
        }
      } else {
        isRecognizing = false;
        btnStart.disabled = false;
        btnStop.disabled = true;
        setStatus('STT ì¢…ë£Œë¨');
      }
    };

    try {
      rec.start();
    } catch (err) {
      console.error('STT ì‹œì‘ ì‹¤íŒ¨:', err);
      setStatus('STT ì‹œì‘ ì‹¤íŒ¨: ' + err.message);
      isRecognizing = false;
      btnStart.disabled = false;
      btnStop.disabled = true;
    }
  }

  function stopSTT() {
    if (rec && isRecognizing) {
      isRecognizing = false; // continuous ëª¨ë“œì—ì„œ ìë™ ì¬ì‹œì‘ ë°©ì§€
      rec.stop();
      setStatus('STT ì¤‘ì§€ ìš”ì²­...');
    }
  }

  btnStart.addEventListener('click', startSTT);
  btnStop.addEventListener('click', stopSTT);

  // -------------------- TTS (voices) --------------------
  function labelForVoice(v) {
    const flags = [
      v.localService ? 'local' : 'remote',
      v.default ? 'default' : ''
    ].filter(Boolean).join(', ');
    return `${v.name} â€” ${v.lang}${flags ? ` (${flags})` : ''}`;
  }

  function fillVoiceList() {
    if (!hasTTS) return;
    const voices = speechSynthesis.getVoices() || [];
    const cur = voiceEl.value;

    voiceEl.innerHTML = '';
    voices.forEach((v, idx) => {
      const opt = document.createElement('option');
      opt.value = String(idx);
      opt.textContent = labelForVoice(v);
      voiceEl.appendChild(opt);
    });

    // ë³µì›
    if (cur && voices[Number(cur)]) voiceEl.value = cur;

    // ìë™ì„ íƒ ì˜µì…˜ì´ ì¼œì ¸ìˆìœ¼ë©´ í˜„ì¬ ì–¸ì–´ì— ë§ì¶° ì„ íƒ
    if (autoPickEl.checked) pickVoiceForLang(langEl.value);
  }

  function pickVoiceForLang(lang) {
    if (!hasTTS) return;
    const voices = speechSynthesis.getVoices() || [];
    if (!voices.length) return;

    let idx = voices.findIndex(v => v.lang === lang);

    if (idx < 0) {
      const base = lang.split('-')[0];
      idx = voices.findIndex(v => v.lang && v.lang.startsWith(base));
    }

    if (idx < 0) idx = voices.findIndex(v => v.default);
    if (idx < 0) idx = 0;

    voiceEl.value = String(idx);
  }

  if (hasTTS) {
    speechSynthesis.onvoiceschanged = () => fillVoiceList();
    fillVoiceList();
  }

  langEl.addEventListener('change', () => {
    if (autoPickEl.checked) pickVoiceForLang(langEl.value);
  });

  // -------------------- TTS speak / pause / resume / cancel --------------------
  function splitText(text, maxLen) {
    const chunks = [];
    let s = text.trim();
    if (!s) return chunks;

    const limit = Math.max(80, Math.min(500, Number(maxLen) || 180));

    while (s.length > limit) {
      let cut = -1;

      const re = /[\.!\?\n]/g;
      let m;
      while ((m = re.exec(s)) !== null) {
        if (m.index < limit) cut = m.index + 1;
        else break;
      }

      if (cut < 0) {
        cut = s.lastIndexOf(' ', limit);
      }

      if (cut < 0 || cut < 20) cut = limit;

      chunks.push(s.slice(0, cut).trim());
      s = s.slice(cut).trim();
    }
    if (s) chunks.push(s);
    return chunks;
  }

  function renderHighlight(fullText, start, end) {
    const a = fullText.slice(0, start);
    const b = fullText.slice(start, end);
    const c = fullText.slice(end);
    const esc = (t) => t.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
    hlEl.innerHTML = `${esc(a)}<mark>${esc(b || ' ')}</mark>${esc(c)}`;
  }

  let currentUtterances = [];
  let fullTextForHighlight = '';
  let globalOffset = 0;

  function speak() {
    if (!hasTTS) { alert('TTS ë¯¸ì§€ì› ë¸Œë¼ìš°ì €ì…ë‹ˆë‹¤.'); return; }

    const raw = textEl.value.trim();
    if (!raw) { alert('ì½ì„ í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.'); return; }

    const queueMode = queueModeEl.checked;

    if (!queueMode) {
      speechSynthesis.cancel();
    }

    const voices = speechSynthesis.getVoices() || [];
    const voiceIdx = Number(voiceEl.value);
    const selectedVoice = voices[voiceIdx] || null;

    const chunks = splitText(raw, chunkLenEl.value);
    if (!chunks.length) return;

    setStatus(`TTS ì‹œì‘ (${chunks.length}ê°œ ì¡°ê°)`);

    // ì›ë³¸ í…ìŠ¤íŠ¸ë¥¼ í•˜ì´ë¼ì´íŠ¸ìš©ìœ¼ë¡œ ì‚¬ìš©
    fullTextForHighlight = raw;
    renderHighlight(fullTextForHighlight, 0, 0);

    currentUtterances = [];
    globalOffset = 0;
    let chunkStartPositions = [0]; // ê° chunkì˜ ì‹œì‘ ìœ„ì¹˜ ì €ì¥

    // ê° chunkì˜ ì‹œì‘ ìœ„ì¹˜ ê³„ì‚°
    let pos = 0;
    for (let i = 0; i < chunks.length - 1; i++) {
      // ì›ë³¸ í…ìŠ¤íŠ¸ì—ì„œ í•´ë‹¹ chunkë¥¼ ì°¾ì•„ ìœ„ì¹˜ ê³„ì‚°
      const chunkText = chunks[i];
      const nextChunkText = chunks[i + 1];
      
      // ì›ë³¸ í…ìŠ¤íŠ¸ì—ì„œ chunkì˜ ì‹¤ì œ ìœ„ì¹˜ ì°¾ê¸°
      let chunkPos = raw.indexOf(chunkText, pos);
      if (chunkPos === -1) {
        // ì •í™•íˆ ì°¾ì§€ ëª»í•˜ë©´ ëŒ€ëµì ì¸ ìœ„ì¹˜ ì‚¬ìš©
        chunkPos = pos;
      }
      pos = chunkPos + chunkText.length;
      chunkStartPositions.push(pos);
    }

    chunks.forEach((chunk, i) => {
      const u = new SpeechSynthesisUtterance(chunk);
      u.lang = langEl.value;
      if (selectedVoice) u.voice = selectedVoice;
      u.rate = Number(rateEl.value);
      u.pitch = Number(pitchEl.value);
      u.volume = Number(volumeEl.value);

      const chunkStart = chunkStartPositions[i] || 0;

      u.onstart = () => {
        setStatus(`TTS ì½ëŠ” ì¤‘... (${i+1}/${chunks.length})`);
        // chunk ì‹œì‘ ì‹œ í•˜ì´ë¼ì´íŠ¸ ì´ˆê¸°í™”
        if (chkBoundary.checked) {
          renderHighlight(fullTextForHighlight, chunkStart, chunkStart);
        }
      };

      u.onend = () => {
        if (i === chunks.length - 1) {
          setStatus('TTS ì™„ë£Œ');
          // ë§ˆì§€ë§‰ chunk ì¢…ë£Œ ì‹œ í•˜ì´ë¼ì´íŠ¸ ì œê±°
          if (chkBoundary.checked) {
            renderHighlight(fullTextForHighlight, fullTextForHighlight.length, fullTextForHighlight.length);
          }
        }
      };

      u.onerror = (e) => {
        setStatus('TTS ì—ëŸ¬: ' + (e.error || 'unknown'));
      };

      if (chkBoundary.checked) {
        u.onboundary = (e) => {
          if (typeof e.charIndex === 'number' && e.charIndex >= 0) {
            // chunk ë‚´ë¶€ì˜ charIndexë¥¼ ì›ë³¸ í…ìŠ¤íŠ¸ì˜ ì ˆëŒ€ ìœ„ì¹˜ë¡œ ë³€í™˜
            const absolutePos = Math.min(fullTextForHighlight.length, chunkStart + e.charIndex);
            const end = Math.min(fullTextForHighlight.length, absolutePos + (e.charLength || 1));
            renderHighlight(fullTextForHighlight, absolutePos, end);
          }
        };
      }

      currentUtterances.push(u);
      speechSynthesis.speak(u);
    });
  }

  function pauseSpeak() {
    if (!hasTTS) return;
    if (speechSynthesis.speaking && !speechSynthesis.paused) {
      speechSynthesis.pause();
      setStatus('TTS ì¼ì‹œì •ì§€');
    }
  }

  function resumeSpeak() {
    if (!hasTTS) return;
    if (speechSynthesis.paused) {
      speechSynthesis.resume();
      setStatus('TTS ì¬ê°œ');
    }
  }

  function cancelSpeak() {
    if (!hasTTS) return;
    speechSynthesis.cancel();
    setStatus('TTS ì·¨ì†Œ');
    hlEl.textContent = '(TTS ì‹œì‘í•˜ë©´ í˜„ì¬ ì½ëŠ” ìœ„ì¹˜ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤)';
  }

  btnSpeak.addEventListener('click', speak);
  btnPause.addEventListener('click', pauseSpeak);
  btnResume.addEventListener('click', resumeSpeak);
  btnCancel.addEventListener('click', cancelSpeak);

  setStatus('ì¤€ë¹„ ì™„ë£Œ');
})();
</script>
</body>
</html>